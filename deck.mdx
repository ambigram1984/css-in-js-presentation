import { future } from '@mdx-deck/themes';
export const theme = [
  future,
  {
    styles: {
      Slide: {
        padding: '20px'
      },
      div: {
        padding: '20px'
      }
    }
  }
];
import { Invert, Split, Image, Notes } from 'mdx-deck';
import { LiveCode } from 'mdx-deck-live-code';

import BasicStylingExample from './emotion-examples/basic-styling';
import CascadeExample from './emotion-examples/cascade';
import ChangeTagExample from './emotion-examples/changing-tags.jsx';
import ReuseStyleExample from './emotion-examples/reuse-styles.jsx';
import GlobalStyles from './emotion-examples/global-styles.jsx';

import VueComponentImage from './vue-component.png';
import EmotionComponentImage from './emotion-everything-in-same-file.png';

# CSS in JS

## Demonstrated with Emotion üë©‚Äçüé§

---

agenda üóìÔ∏è

- Why CSS in JS?
- Examples with Emotion

---

<Invert>No, really? Y tho?</Invert>

---

> Although there are different ways to get there, an in depth understanding of CSS will help you make the right decisions.
> -- <cite>Unkown</cite>

In my opinion, CSS in JS is an alternative to pre-processors. We are still leveraging out exsisting knowledge of CSS;
however we now have different ways of managing/maintaining the code produces our css, in addition to new capabilities that
are not possible with SASS

---

drawbacks of css-in-js üò¨

- More tools to learn and manage
  - Not the old way.
    - SASS was new once upon a time.
  - Some designers also write css, which now introduces a knowledge of javascript.
    - the jump in syntax is not that huge if a developer is used to writing SASS.
      The larger issue here would be project structure, which is something a team should already
      be collaborating on.

---

drawbacks of css-in-js üò¨

- Have to ship the run time.
  - Takes a performance hit.
    - theres also a performance gain in only loading required styles
    - unless your using a library that supports but that has other issues.
- Committing to a library
  - material-UI uses JSS üí©(lol j/k; it's just not for me.)
- Loose the cascade
  - this is also a pro of using CSS-in-JS.

---

benefits ü§ò

> What can we do with CSS-in-JS that we can‚Äôt do with SASS/CSS Modules?

- Capable of static analysis.
- Run time style generation/manipulation.
- Javascript >= Sass.
- Everything in the same file.

---

capable of static analysis üîé

- Type enforcement
  - we can assert on the validity of CSS.
- derver Rendering
  - no additonal to config to use critical styles when using Next.js.
- Dead code elimination

---

run time style generation/manipulation üèÉ

- Previously we could only manipulate styles at build time.
  - Example: Imagine generating a grid.
- We no longer use classnames, just style objects or components.
  - no more name collisons
  - no more cascade
  - global library style support is easy in emotion.

---

javascript >= sass üõ†Ô∏è

- JS can do everything SASS can do.
  - functions, spread, variables, etc..
- Things like Stylis.js can be used for pre-processing
  - vendor prefixes, converting colors to hex

---

a lesson from vue.js üî≠

<Split>

- I remember thinking React was dumb because it mixed HTML/JS ü§ì
- Including styles in the same file was originally pioneered by Vue.js (I think lol)
- Code is more readable as we do not have to navigate multiple files to tell what is going on

<img src={VueComponentImage} width="65%" alt="Example of vue code" />

</Split>

<Notes>- Working with Backbone.js required three files to be open.</Notes>

---

everything in same file üìù

<Split>

- From looking at the component we can see styles and not class properties.
- We know these styles are only d to this file.
- We can see how props affect properties intsead of manipulating class names.

<img src={EmotionComponentImage} alt="Example of emotion code" />

</Split>

---

<Invert> Examples with Emotion </Invert>

---

<BasicStylingExample />

---

<ReuseStyleExample />

---

<CascadeExample />

---

<ChangeTagExample />

---

<GlobalStyles />

---

how does this work?

When calling things such as `h1.styled` emotion takes the styles past to that funtion, hashes them to create
a class name, and then inserts them into the `head` of the document in a `style` tag.

---

popular alternatives to emotion

- Linaria
  - Generates a static css file so there's no need to ship a run time
  - Looses some of the dynamic features

---

# Questions üôã

<Notes>
  <h1> Differences from inline styling </h1>
  <ul>
    <li>
      Have to implement work arounds for things like pseudo selectors and media
      queries
    </li>
    <li>Loss of global styles</li>
    <li>Styles are in dom, which make dev tools super hard to readable</li>
    <li>
      Rendering performance takes a hit because each node's style tag has to be
      evaluated
    </li>
  </ul>
</Notes>
